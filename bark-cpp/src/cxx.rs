use crate::cxx::ffi::{
    ArkoorPaymentResult, BarkMovement, BarkVtxo, OnchainPaymentResult, PaymentTypes, RoundStatus,
};
use crate::{utils, TOKIO_RUNTIME};
use anyhow::{bail, Context, Ok};
use bark::ark::bitcoin::hex::DisplayHex;
use bark::ark::bitcoin::{address, Address};
use bark::ark::lightning::{self, PaymentHash};
use bdk_wallet::bitcoin::{self, network, FeeRate};
use bip39::Mnemonic;
use logger::log::{self, info};

use std::path::Path;
use std::str::FromStr;

#[cxx::bridge(namespace = "bark_cxx")]
pub(crate) mod ffi {

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct BarkVtxo {
        amount: u64,
        expiry_height: u32,
        server_pubkey: String,
        exit_delta: u16,
        anchor_point: String,
        point: String,
        state: String,
    }

    pub enum PaymentTypes {
        Bolt11,
        Bolt12,
        Lnurl,
        Arkoor,
        Onchain,
    }

    pub struct BoardResult {
        vtxos: Vec<String>,
        funding_txid: String,
    }

    pub struct NewAddressResult {
        user_pubkey: String,
        ark_id: String,
        address: String,
    }

    pub struct Bolt11Invoice {
        bolt11_invoice: String,
        payment_secret: String,
        payment_hash: String,
    }

    pub struct LightningSend {
        pub invoice: String,
        pub amount: u64,
        pub htlc_vtxos: Vec<BarkVtxo>,
        pub movement_id: u32,
        pub preimage: String,
    }

    pub struct ArkoorPaymentResult {
        amount_sat: u64,
        destination_pubkey: String,
        payment_type: PaymentTypes,
        vtxos: Vec<BarkVtxo>,
    }

    pub struct OnchainPaymentResult {
        txid: String,
        amount_sat: u64,
        destination_address: String,
        payment_type: PaymentTypes,
    }

    pub struct CxxArkInfo {
        network: String,
        server_pubkey: String,
        round_interval: u64,
        nb_round_nonces: u16,
        vtxo_exit_delta: u16,
        vtxo_expiry_delta: u16,
        htlc_send_expiry_delta: u16,
        max_vtxo_amount: u64,
        required_board_confirmations: u8,
    }

    pub struct ConfigOpts {
        ark: String,
        esplora: String,
        bitcoind: String,
        bitcoind_cookie: String,
        bitcoind_user: String,
        bitcoind_pass: String,
        vtxo_refresh_expiry_threshold: u32,
        fallback_fee_rate: u64,
        htlc_recv_claim_delta: u16,
        vtxo_exit_margin: u16,
        round_tx_required_confirmations: u32,
    }

    pub struct CreateOpts {
        regtest: bool,
        signet: bool,
        bitcoin: bool,
        mnemonic: String,
        birthday_height: *const u32,
        config: ConfigOpts,
    }

    pub struct SendManyOutput {
        destination: String,
        amount_sat: u64,
    }

    pub enum RefreshModeType {
        DefaultThreshold,
        ThresholdBlocks,
        ThresholdHours,
        Counterparty,
        All,
        Specific,
    }

    pub struct LightningReceive {
        pub payment_hash: String,
        pub payment_preimage: String,
        pub invoice: String,
        pub preimage_revealed_at: *const u64,
    }

    pub struct LightningReceiveBalance {
        /// Sum of all pending lightning invoices
        pub total: u64,
        /// Sum of all invoices for which we received the HTLC VTXOs
        pub claimable: u64,
    }

    pub struct OffchainBalance {
        /// Coins that are spendable in the Ark, either in-round or out-of-round.
        pub spendable: u64,
        /// Coins that are in the process of being sent over Lightning.
        pub pending_lightning_send: u64,
        /// Coins locked in a round.
        pub pending_in_round: u64,
        /// Coins that are in the process of unilaterally exiting the Ark.
        pub pending_exit: u64,
        /// Coins that are pending sufficient confirmations from board transactions.
        pub pending_board: u64,
    }

    pub struct OnChainBalance {
        /// All coinbase outputs not yet matured
        pub immature: u64,
        /// Unconfirmed UTXOs generated by a wallet tx
        pub trusted_pending: u64,
        /// Unconfirmed UTXOs received from an external wallet
        pub untrusted_pending: u64,
        /// Confirmed and immediately spendable balance
        pub confirmed: u64,
    }

    pub struct KeyPairResult {
        pub public_key: String,
        pub secret_key: String,
    }

    pub struct BarkMovementDestination {
        pub destination: String,
        pub payment_method: String,
        pub amount_sat: u64,
    }

    pub struct BarkMovement {
        pub id: u32,
        pub status: String,
        pub subsystem_name: String,
        pub subsystem_kind: String,
        pub metadata_json: String,
        pub intended_balance_sat: i64,
        pub effective_balance_sat: i64,
        pub offchain_fee_sat: u64,
        pub sent_to: Vec<BarkMovementDestination>,
        pub received_on: Vec<BarkMovementDestination>,
        pub input_vtxos: Vec<String>,
        pub output_vtxos: Vec<String>,
        pub exited_vtxos: Vec<String>,
        pub created_at: String,
        pub updated_at: String,
        pub completed_at: String,
    }

    pub struct RoundStatus {
        pub status: String,
        pub funding_txid: String,
        pub unsigned_funding_txids: Vec<String>,
        pub error: String,
        pub is_final: bool,
        pub is_success: bool,
    }

    extern "Rust" {
        fn init_logger();
        fn create_mnemonic() -> Result<String>;
        fn is_wallet_loaded() -> bool;
        fn close_wallet() -> Result<()>;
        fn get_ark_info() -> Result<CxxArkInfo>;
        fn offchain_balance() -> Result<OffchainBalance>;
        fn derive_store_next_keypair() -> Result<KeyPairResult>;
        fn peak_keypair(index: u32) -> Result<KeyPairResult>;
        fn new_address() -> Result<NewAddressResult>;
        fn peak_address(index: u32) -> Result<NewAddressResult>;
        fn sign_message(message: &str, index: u32) -> Result<String>;
        fn sign_messsage_with_mnemonic(
            message: &str,
            mnemonic: &str,
            network: &str,
            index: u32,
        ) -> Result<String>;
        fn derive_keypair_from_mnemonic(
            mnemonic: &str,
            network: &str,
            index: u32,
        ) -> Result<KeyPairResult>;
        fn verify_message(message: &str, signature: &str, public_key: &str) -> Result<bool>;
        fn movements() -> Result<Vec<BarkMovement>>;
        fn vtxos() -> Result<Vec<BarkVtxo>>;
        fn get_expiring_vtxos(threshold: u32) -> Result<Vec<BarkVtxo>>;
        fn get_first_expiring_vtxo_blockheight() -> Result<*const u32>;
        fn get_next_required_refresh_blockheight() -> Result<*const u32>;
        fn bolt11_invoice(amount_msat: u64) -> Result<Bolt11Invoice>;
        fn lightning_receive_status(payment_hash: String) -> Result<*const LightningReceive>;
        fn check_lightning_payment(payment_hash: String, wait: bool) -> Result<String>;
        fn sync_pending_boards() -> Result<()>;
        fn maintenance() -> Result<()>;
        fn maintenance_with_onchain() -> Result<()>;
        fn maintenance_refresh() -> Result<()>;
        fn refresh_server() -> Result<()>;
        fn sync() -> Result<()>;
        fn create_wallet(datadir: &str, opts: CreateOpts) -> Result<()>;
        fn load_wallet(datadir: &str, config: CreateOpts) -> Result<()>;
        fn board_amount(amount_sat: u64) -> Result<BoardResult>;
        fn board_all() -> Result<BoardResult>;
        fn validate_arkoor_address(address: &str) -> Result<()>;
        fn send_arkoor_payment(destination: &str, amount_sat: u64) -> Result<ArkoorPaymentResult>;
        unsafe fn pay_lightning_invoice(
            destination: &str,
            amount_sat: *const u64,
        ) -> Result<LightningSend>;
        unsafe fn pay_lightning_offer(offer: &str, amount_sat: *const u64)
            -> Result<LightningSend>;
        fn pay_lightning_address(
            addr: &str,
            amount_sat: u64,
            comment: &str,
        ) -> Result<LightningSend>;
        fn send_round_onchain_payment(destination: &str, amount_sat: u64) -> Result<RoundStatus>;
        fn offboard_specific(
            vtxo_ids: Vec<String>,
            destination_address: &str,
        ) -> Result<RoundStatus>;
        fn offboard_all(destination_address: &str) -> Result<RoundStatus>;
        unsafe fn try_claim_lightning_receive(
            payment_hash: String,
            wait: bool,
            token: *const String,
        ) -> Result<()>;
        fn try_claim_all_lightning_receives(wait: bool) -> Result<()>;
        fn sync_exits() -> Result<()>;
        fn sync_pending_rounds() -> Result<()>;

        // Onchain methods
        fn onchain_balance() -> Result<OnChainBalance>;
        fn onchain_sync() -> Result<()>;
        fn onchain_list_unspent() -> Result<String>;
        fn onchain_utxos() -> Result<String>;
        fn onchain_address() -> Result<String>;
        unsafe fn onchain_send(
            destination: &str,
            amount_sat: u64,
            fee_rate: *const u64,
        ) -> Result<OnchainPaymentResult>;
        unsafe fn onchain_drain(destination: &str, fee_rate: *const u64) -> Result<String>;
        unsafe fn onchain_send_many(
            outputs: Vec<SendManyOutput>,
            fee_rate: *const u64,
        ) -> Result<String>;
    }
}

pub(crate) fn init_logger() {
    crate::init_logger()
}

pub(crate) fn create_mnemonic() -> anyhow::Result<String> {
    crate::create_mnemonic()
}

pub(crate) fn is_wallet_loaded() -> bool {
    crate::TOKIO_RUNTIME.block_on(crate::is_wallet_loaded())
}

pub(crate) fn close_wallet() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::close_wallet())
}

pub(crate) fn get_ark_info() -> anyhow::Result<ffi::CxxArkInfo> {
    let info = crate::TOKIO_RUNTIME.block_on(crate::get_ark_info())?;
    Ok(ffi::CxxArkInfo {
        network: info.network.to_string(),
        server_pubkey: info.server_pubkey.to_string(),
        round_interval: info.round_interval.as_secs(),
        nb_round_nonces: info.nb_round_nonces as u16,
        vtxo_exit_delta: info.vtxo_exit_delta,
        vtxo_expiry_delta: info.vtxo_expiry_delta,
        htlc_send_expiry_delta: info.htlc_send_expiry_delta,
        max_vtxo_amount: info.max_vtxo_amount.map_or(0, |a| a.to_sat()),
        required_board_confirmations: info.required_board_confirmations as u8,
    })
}

pub(crate) fn offchain_balance() -> anyhow::Result<ffi::OffchainBalance> {
    let balance = crate::TOKIO_RUNTIME.block_on(crate::balance())?;
    Ok(ffi::OffchainBalance {
        spendable: balance.spendable.to_sat(),
        pending_lightning_send: balance.pending_lightning_send.to_sat(),

        pending_in_round: balance.pending_in_round.to_sat(),
        pending_exit: balance.pending_exit.map_or(0, |a| a.to_sat()),
        pending_board: balance.pending_board.to_sat(),
    })
}

pub(crate) fn derive_store_next_keypair() -> anyhow::Result<ffi::KeyPairResult> {
    let keypair = crate::TOKIO_RUNTIME.block_on(crate::derive_store_next_keypair())?;
    Ok(ffi::KeyPairResult {
        public_key: keypair.public_key().to_string(),
        secret_key: keypair.secret_key().display_secret().to_string(),
    })
}

pub(crate) fn peak_keypair(index: u32) -> anyhow::Result<ffi::KeyPairResult> {
    let keypair = crate::TOKIO_RUNTIME.block_on(crate::peak_keypair(index))?;
    Ok(ffi::KeyPairResult {
        public_key: keypair.public_key().to_string(),
        secret_key: keypair.secret_key().display_secret().to_string(),
    })
}

pub(crate) fn new_address() -> anyhow::Result<ffi::NewAddressResult> {
    let address = crate::TOKIO_RUNTIME.block_on(crate::new_address())?;
    Ok(ffi::NewAddressResult {
        user_pubkey: address.policy().user_pubkey().to_string(),
        ark_id: address.ark_id().to_string(),
        address: address.to_string(),
    })
}

pub(crate) fn peak_address(index: u32) -> anyhow::Result<ffi::NewAddressResult> {
    let address = crate::TOKIO_RUNTIME.block_on(crate::peak_address(index))?;
    Ok(ffi::NewAddressResult {
        user_pubkey: address.policy().user_pubkey().to_string(),
        ark_id: address.ark_id().to_string(),
        address: address.to_string(),
    })
}

pub(crate) fn sign_message(message: &str, index: u32) -> anyhow::Result<String> {
    let message = crate::TOKIO_RUNTIME
        .block_on(crate::sign_message(message, index))?
        .to_string();
    Ok(message)
}

pub(crate) fn sign_messsage_with_mnemonic(
    message: &str,
    mnemonic: &str,
    network: &str,
    index: u32,
) -> anyhow::Result<String> {
    let mnemonic = Mnemonic::from_str(mnemonic)
        .with_context(|| format!("Invalid mnemonic format: '{}'", mnemonic))?;

    let network = match network {
        "mainnet" => network::Network::Bitcoin,
        "regtest" => network::Network::Regtest,
        "signet" => network::Network::Signet,
        _ => bail!("Invalid network format: '{}'", network),
    };

    let message = crate::TOKIO_RUNTIME
        .block_on(crate::sign_messsage_with_mnemonic(
            message, mnemonic, network, index,
        ))?
        .to_string();
    Ok(message)
}

pub(crate) fn derive_keypair_from_mnemonic(
    mnemonic: &str,
    network: &str,
    index: u32,
) -> anyhow::Result<ffi::KeyPairResult> {
    let mnemonic = bip39::Mnemonic::from_str(mnemonic)
        .with_context(|| format!("Invalid mnemonic format: '{}'", mnemonic))?;
    let network = match network {
        "mainnet" => network::Network::Bitcoin,
        "regtest" => network::Network::Regtest,
        "signet" => network::Network::Signet,
        _ => bail!("Invalid network format: '{}'", network),
    };

    let keypair = crate::TOKIO_RUNTIME.block_on(crate::derive_keypair_from_mnemonic(
        mnemonic, network, index,
    ))?;

    Ok(ffi::KeyPairResult {
        public_key: keypair.public_key().to_string(),
        secret_key: keypair.secret_key().display_secret().to_string(),
    })
}

pub(crate) fn verify_message(
    message: &str,
    signature: &str,
    public_key: &str,
) -> anyhow::Result<bool> {
    let signature = bark::ark::bitcoin::secp256k1::ecdsa::Signature::from_str(signature)
        .with_context(|| format!("Invalid signature format: '{}'", signature))?;
    let public_key = bark::ark::bitcoin::secp256k1::PublicKey::from_str(public_key)
        .with_context(|| format!("Invalid public key format: '{}'", public_key))?;

    crate::TOKIO_RUNTIME.block_on(crate::verify_message(message, signature, &public_key))
}

pub(crate) fn movements() -> anyhow::Result<Vec<BarkMovement>> {
    let movements = crate::TOKIO_RUNTIME.block_on(crate::movements())?;
    fn fun_name(m: &bark::movement::Movement) -> Result<BarkMovement, anyhow::Error> {
        utils::movement_to_bark_movement(m)
    }

    movements.iter().map(fun_name).collect()
}

pub(crate) fn vtxos() -> anyhow::Result<Vec<BarkVtxo>> {
    let vtxos = crate::TOKIO_RUNTIME.block_on(crate::vtxos())?;
    Ok(vtxos
        .into_iter()
        .map(utils::wallet_vtxo_to_bark_vtxo)
        .collect())
}

pub(crate) fn get_expiring_vtxos(threshold: u32) -> anyhow::Result<Vec<BarkVtxo>> {
    let expiring_vtxos = crate::TOKIO_RUNTIME.block_on(crate::get_expiring_vtxos(threshold))?;
    Ok(expiring_vtxos
        .into_iter()
        .map(utils::wallet_vtxo_to_bark_vtxo)
        .collect())
}

pub(crate) fn get_first_expiring_vtxo_blockheight() -> anyhow::Result<*const u32> {
    let blockheight = crate::TOKIO_RUNTIME.block_on(crate::get_first_expiring_vtxo_blockheight())?;
    match blockheight {
        Some(height) => Ok(Box::into_raw(Box::new(height))),
        None => Ok(std::ptr::null()),
    }
}

pub(crate) fn get_next_required_refresh_blockheight() -> anyhow::Result<*const u32> {
    let blockheight =
        crate::TOKIO_RUNTIME.block_on(crate::get_next_required_refresh_blockheight())?;
    match blockheight {
        Some(height) => Ok(Box::into_raw(Box::new(height))),
        None => Ok(std::ptr::null()),
    }
}

pub(crate) fn bolt11_invoice(amount_msat: u64) -> anyhow::Result<ffi::Bolt11Invoice> {
    let invoice = crate::TOKIO_RUNTIME.block_on(crate::bolt11_invoice(amount_msat))?;
    Ok(ffi::Bolt11Invoice {
        bolt11_invoice: invoice.to_string(),
        payment_secret: invoice.payment_secret().to_string(),
        payment_hash: invoice.payment_hash().to_string(),
    })
}

pub(crate) fn lightning_receive_status(
    payment_hash: String,
) -> anyhow::Result<*const ffi::LightningReceive> {
    let payment = bark::ark::lightning::PaymentHash::from_str(&payment_hash)
        .with_context(|| format!("Invalid payment hash format: '{}'", payment_hash))?;
    let status = crate::TOKIO_RUNTIME.block_on(crate::lightning_receive_status(payment))?;

    if status.is_none() {
        return Ok(std::ptr::null());
    }

    let status = status.unwrap();
    let status = Box::new(ffi::LightningReceive {
        payment_hash: status.payment_hash.to_string(),
        payment_preimage: status.payment_preimage.to_string(),
        invoice: status.invoice.to_string(),
        preimage_revealed_at: status.preimage_revealed_at.map_or(std::ptr::null(), |v| {
            Box::into_raw(Box::new(v.timestamp() as u64))
        }),
    });
    Ok(Box::into_raw(status))
}

pub(crate) fn sync_pending_boards() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::sync_pending_boards())
}

pub(crate) fn maintenance() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::maintenance())
}

pub(crate) fn maintenance_with_onchain() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::maintenance_with_onchain())
}

pub(crate) fn maintenance_refresh() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::maintenance_refresh())
}

pub(crate) fn refresh_server() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::refresh_server())
}

pub(crate) fn sync() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::sync())
}

pub(crate) fn create_wallet(datadir: &str, opts: ffi::CreateOpts) -> anyhow::Result<()> {
    let create_opts = utils::ffi_config_to_config(opts)?;

    log::info!("Creating wallet with options: {:?}", create_opts);

    crate::TOKIO_RUNTIME.block_on(crate::create_wallet(Path::new(datadir), create_opts))
}

pub(crate) fn load_wallet(datadir: &str, config: ffi::CreateOpts) -> anyhow::Result<()> {
    let mnemonic = bip39::Mnemonic::from_str(&config.mnemonic)
        .with_context(|| format!("Invalid mnemonic format: '{}'", config.mnemonic))?;

    log::info!("Loading wallet with datadir: {}", datadir);

    let create_opts = utils::ffi_config_to_config(config)?;

    let (config, _) = utils::merge_config_opts(create_opts)?;

    crate::TOKIO_RUNTIME.block_on(crate::load_wallet(Path::new(datadir), mnemonic, config))
}

pub(crate) fn board_amount(amount_sat: u64) -> anyhow::Result<ffi::BoardResult> {
    let amount = bark::ark::bitcoin::Amount::from_sat(amount_sat);
    let board_result = crate::TOKIO_RUNTIME.block_on(crate::board_amount(amount))?;

    Ok(ffi::BoardResult {
        vtxos: board_result
            .vtxos
            .iter()
            .map(|vtxo| vtxo.to_string())
            .collect(),
        funding_txid: board_result.funding_tx.compute_txid().to_string(),
    })
}

pub(crate) fn board_all() -> anyhow::Result<ffi::BoardResult> {
    let board_result = crate::TOKIO_RUNTIME.block_on(crate::board_all())?;

    Ok(ffi::BoardResult {
        vtxos: board_result
            .vtxos
            .iter()
            .map(|vtxo| vtxo.to_string())
            .collect(),
        funding_txid: board_result.funding_tx.compute_txid().to_string(),
    })
}

pub(crate) fn validate_arkoor_address(address: &str) -> anyhow::Result<()> {
    let address = bark::ark::Address::from_str(address)
        .with_context(|| format!("Invalid address format: '{}'", address))?;
    crate::TOKIO_RUNTIME.block_on(crate::validate_arkoor_address(address))
}

pub(crate) fn send_arkoor_payment(
    destination: &str,
    amount_sat: u64,
) -> anyhow::Result<ArkoorPaymentResult> {
    let amount = bark::ark::bitcoin::Amount::from_sat(amount_sat);
    let dest = bark::ark::Address::from_str(destination)
        .with_context(|| format!("Invalid destination address format: '{}'", destination))?;
    let oor_result = crate::TOKIO_RUNTIME.block_on(crate::send_arkoor_payment(dest, amount))?;

    Ok(ArkoorPaymentResult {
        vtxos: oor_result.iter().map(utils::vtxo_to_bark_vtxo).collect(),
        destination_pubkey: destination.to_string(),
        amount_sat,
        payment_type: PaymentTypes::Arkoor,
    })
}

pub(crate) fn pay_lightning_invoice(
    destination: &str,
    amount_sat: *const u64,
) -> anyhow::Result<ffi::LightningSend> {
    let amount_opt =
        unsafe { amount_sat.as_ref().map(|r| *r) }.map(bark::ark::bitcoin::Amount::from_sat);

    let invoice = lightning::Invoice::from_str(destination)?;

    let send_result =
        crate::TOKIO_RUNTIME.block_on(crate::pay_lightning_invoice(invoice, amount_opt))?;

    Ok(ffi::LightningSend {
        htlc_vtxos: send_result
            .htlc_vtxos
            .into_iter()
            .map(utils::wallet_vtxo_to_bark_vtxo)
            .collect(),
        amount: send_result.amount.to_sat(),
        invoice: send_result.invoice.to_string(),
        movement_id: send_result.movement_id.0,
        preimage: send_result
            .preimage
            .map_or(String::new(), |p| p.to_lower_hex_string()),
    })
}

pub(crate) fn pay_lightning_offer(
    offer: &str,
    amount_sat: *const u64,
) -> anyhow::Result<ffi::LightningSend> {
    let amount_opt =
        unsafe { amount_sat.as_ref().map(|r| *r) }.map(bark::ark::bitcoin::Amount::from_sat);

    let offer = lightning::Offer::from_str(offer)
        .map_err(|err| anyhow::anyhow!("Failed to parse bolt12 offer: {:?}", err))?;

    let send_result =
        crate::TOKIO_RUNTIME.block_on(crate::pay_lightning_offer(offer.clone(), amount_opt))?;

    Ok(ffi::LightningSend {
        htlc_vtxos: send_result
            .htlc_vtxos
            .into_iter()
            .map(utils::wallet_vtxo_to_bark_vtxo)
            .collect(),
        amount: send_result.amount.to_sat(),
        invoice: send_result.invoice.to_string(),
        movement_id: send_result.movement_id.0,
        preimage: send_result
            .preimage
            .map_or(String::new(), |p| p.to_lower_hex_string()),
    })
}

pub(crate) fn pay_lightning_address(
    addr: &str,
    amount_sat: u64,
    comment: &str,
) -> anyhow::Result<ffi::LightningSend> {
    let amount = bark::ark::bitcoin::Amount::from_sat(amount_sat);
    let comment_opt = if comment.is_empty() {
        None
    } else {
        Some(comment)
    };
    let send_result =
        crate::TOKIO_RUNTIME.block_on(crate::pay_lightning_address(addr, amount, comment_opt))?;

    Ok(ffi::LightningSend {
        htlc_vtxos: send_result
            .htlc_vtxos
            .into_iter()
            .map(utils::wallet_vtxo_to_bark_vtxo)
            .collect(),
        amount: send_result.amount.to_sat(),
        invoice: send_result.invoice.to_string(),
        movement_id: send_result.movement_id.0,
        preimage: send_result
            .preimage
            .map_or(String::new(), |p| p.to_lower_hex_string()),
    })
}

pub(crate) fn send_round_onchain_payment(
    destination: &str,
    amount_sat: u64,
) -> anyhow::Result<RoundStatus> {
    let amount = bark::ark::bitcoin::Amount::from_sat(amount_sat);
    let address_unchecked = bitcoin::Address::from_str(destination)
        .with_context(|| format!("Invalid destination address format: '{}'", destination))?;

    let ark_info = crate::TOKIO_RUNTIME.block_on(crate::get_ark_info())?;

    // Now require the network to match the wallet's network
    let destination_address = address_unchecked
        .require_network(ark_info.network)
        .with_context(|| {
            format!(
                "address '{}' is not valid for configured network {}",
                destination, ark_info.network
            )
        })?;

    let result = crate::TOKIO_RUNTIME.block_on(crate::send_round_onchain_payment(
        destination_address,
        amount,
    ))?;

    Ok(utils::round_status_to_ffi(result))
}

pub(crate) fn offboard_specific(
    vtxo_ids: Vec<String>,
    destination_address: &str,
) -> anyhow::Result<RoundStatus> {
    let ids = vtxo_ids
        .into_iter()
        .map(|s| bark::ark::VtxoId::from_str(&s))
        .collect::<Result<Vec<_>, _>>()?;

    let ark_info = crate::TOKIO_RUNTIME.block_on(crate::get_ark_info())?;

    let destination_address_opt =
        Address::<address::NetworkUnchecked>::from_str(destination_address).with_context(|| {
            format!(
                "Invalid destination address format: '{}'",
                destination_address
            )
        })?;
    let addr = destination_address_opt
        .require_network(ark_info.network)
        .with_context(|| {
            format!(
                "Address '{}' is not valid for configured network {:?}",
                destination_address, ark_info.network
            )
        })?;

    if ids.is_empty() {
        bail!("At least one VTXO ID must be provided for specific offboarding");
    }

    info!(
        "Attempting to offboard {} specific VTXOs to {:?}",
        ids.len(),
        addr
    );

    let offboard_specific_result =
        crate::TOKIO_RUNTIME.block_on(crate::offboard_specific(ids, addr))?;

    Ok(utils::round_status_to_ffi(offboard_specific_result))
}

pub(crate) fn offboard_all(destination_address: &str) -> anyhow::Result<RoundStatus> {
    let ark_info = crate::TOKIO_RUNTIME.block_on(crate::get_ark_info())?;

    let destination_address_opt =
        Address::<address::NetworkUnchecked>::from_str(destination_address).with_context(|| {
            format!(
                "Invalid destination address format: '{}'",
                destination_address
            )
        })?;
    let addr = destination_address_opt
        .require_network(ark_info.network)
        .with_context(|| {
            format!(
                "Address '{}' is not valid for configured network {:?}",
                destination_address, ark_info.network
            )
        })?;

    info!("Attempting to offboard all VTXOs to {:?}", addr);

    let offboard_all_result = crate::TOKIO_RUNTIME.block_on(crate::offboard_all(addr))?;

    Ok(utils::round_status_to_ffi(offboard_all_result))
}

pub(crate) fn try_claim_lightning_receive(
    payment_hash: String,
    wait: bool,
    token: *const String,
) -> anyhow::Result<()> {
    let payment_hash = PaymentHash::from_str(&payment_hash)?;
    let token_opt = unsafe { token.as_ref().map(|s| s.clone()) };

    TOKIO_RUNTIME.block_on(crate::try_claim_lightning_receive(
        payment_hash,
        wait,
        token_opt,
    ))
}

pub(crate) fn try_claim_all_lightning_receives(wait: bool) -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::try_claim_all_lightning_receives(wait))?;
    Ok(())
}

pub(crate) fn check_lightning_payment(payment_hash: String, wait: bool) -> anyhow::Result<String> {
    let payment_hash = PaymentHash::from_str(&payment_hash)?;
    let result =
        crate::TOKIO_RUNTIME.block_on(crate::check_lightning_payment(payment_hash, wait))?;
    Ok(result.map_or(String::new(), |p| p.to_lower_hex_string()))
}

pub(crate) fn sync_exits() -> anyhow::Result<()> {
    TOKIO_RUNTIME.block_on(crate::sync_exits())
}

pub(crate) fn sync_pending_rounds() -> anyhow::Result<()> {
    TOKIO_RUNTIME.block_on(crate::sync_pending_rounds())
}

// Onchain methods

pub(crate) fn onchain_list_unspent() -> anyhow::Result<String> {
    let unspent = TOKIO_RUNTIME.block_on(crate::onchain::list_unspent())?;
    serde_json::to_string(&unspent).map_err(Into::into)
}

pub(crate) fn onchain_sync() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::onchain::sync())?;
    Ok(())
}

pub(crate) fn onchain_address() -> anyhow::Result<String> {
    let address = crate::TOKIO_RUNTIME.block_on(crate::onchain::address())?;
    Ok(address.to_string())
}

pub(crate) fn onchain_balance() -> anyhow::Result<ffi::OnChainBalance> {
    let balance = crate::TOKIO_RUNTIME.block_on(crate::onchain::onchain_balance())?;
    Ok(ffi::OnChainBalance {
        immature: balance.immature.to_sat(),
        trusted_pending: balance.trusted_pending.to_sat(),
        untrusted_pending: balance.untrusted_pending.to_sat(),
        confirmed: balance.confirmed.to_sat(),
    })
}

pub(crate) fn onchain_utxos() -> anyhow::Result<String> {
    let utxos = crate::TOKIO_RUNTIME.block_on(async { crate::onchain::utxos().await })?;

    let res = utxos
        .iter()
        .map(|utxo| match utxo {
            bark::onchain::Utxo::Local(local) => serde_json::json!({
                "outpoint": format!("{}:{}", local.outpoint.txid, local.outpoint.vout),
                "amount": local.amount.to_sat(),
                "confirmation_height": local.confirmation_height.map_or(0, |_h| 0),
            }),
            bark::onchain::Utxo::Exit(exit) => serde_json::json!({
                "vtxo": utils::vtxo_to_bark_vtxo(&exit.vtxo),
                "height": exit.height
            }),
        })
        .collect::<Vec<_>>();

    serde_json::to_string(&res).map_err(Into::into)
}

pub(crate) fn onchain_send(
    destination: &str,
    amount_sat: u64,
    fee_rate: *const u64,
) -> anyhow::Result<OnchainPaymentResult> {
    let amount = bark::ark::bitcoin::Amount::from_sat(amount_sat);

    let ark_info = crate::TOKIO_RUNTIME.block_on(crate::get_ark_info())?;

    // Validate optional address string
    let address_unchecked = Address::<address::NetworkUnchecked>::from_str(destination)
        .with_context(|| format!("invalid destination address format: '{}'", destination))?;

    // Now require the network to match the wallet's network
    let destination_address = address_unchecked
        .require_network(ark_info.network)
        .with_context(|| {
            format!(
                "address '{}' is not valid for configured network {}",
                destination, ark_info.network
            )
        })?;

    let txid = crate::TOKIO_RUNTIME.block_on(async {
        let fee_rate = if fee_rate.is_null() {
            let mut manager = crate::GLOBAL_WALLET_MANAGER.lock().await;
            manager
                .with_context_async(|ctx| async { Ok(ctx.wallet.chain.fee_rates().await.regular) })
                .await?
        } else {
            FeeRate::from_sat_per_vb(unsafe { *fee_rate }).context("Invalid fee rate")?
        };

        crate::onchain::send(destination_address.clone(), amount, fee_rate).await
    })?;

    Ok(OnchainPaymentResult {
        txid: txid.to_string(),
        amount_sat,
        destination_address: destination_address.to_string(),
        payment_type: PaymentTypes::Onchain,
    })
}

pub(crate) fn onchain_drain(destination: &str, fee_rate: *const u64) -> anyhow::Result<String> {
    let txid = crate::TOKIO_RUNTIME.block_on(async {
        let mut manager = crate::GLOBAL_WALLET_MANAGER.lock().await;
        let (address, fee_rate) = manager
            .with_context_async(|ctx| async {
                let net = ctx.wallet.properties().unwrap().network;
                let address = Address::from_str(destination)?
                    .require_network(net)
                    .context("Address on wrong network")?;
                let fee_rate = if fee_rate.is_null() {
                    ctx.wallet.chain.fee_rates().await.regular
                } else {
                    FeeRate::from_sat_per_vb(unsafe { *fee_rate }).context("Invalid fee rate")?
                };
                Ok((address, fee_rate))
            })
            .await?;

        crate::onchain::drain(address, fee_rate).await
    })?;
    Ok(txid.to_string())
}

pub(crate) fn onchain_send_many(
    outputs: Vec<ffi::SendManyOutput>,
    fee_rate: *const u64,
) -> anyhow::Result<String> {
    let txid = crate::TOKIO_RUNTIME.block_on(async {
        let mut manager = crate::GLOBAL_WALLET_MANAGER.lock().await;
        let (destinations, fee_rate) = manager
            .with_context_async(|ctx| async {
                let mut destinations = Vec::new();
                let net = ctx.wallet.properties().unwrap().network;
                for output in outputs {
                    let address = Address::from_str(&output.destination)
                        .context("Invalid address format")?
                        .require_network(net)
                        .context("Address on wrong network")?;
                    let amount = bark::ark::bitcoin::Amount::from_sat(output.amount_sat);
                    destinations.push((address, amount));
                }

                let fee_rate = if fee_rate.is_null() {
                    ctx.wallet.chain.fee_rates().await.regular
                } else {
                    FeeRate::from_sat_per_vb(unsafe { *fee_rate }).context("Invalid fee rate")?
                };
                Ok((destinations, fee_rate))
            })
            .await?;

        crate::onchain::send_many(&destinations, fee_rate).await
    })?;
    Ok(txid.to_string())
}
