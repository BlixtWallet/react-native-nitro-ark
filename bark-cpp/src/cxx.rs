use crate::cxx::ffi::{
    ArkoorPaymentResult, BarkVtxo, Bolt11PaymentResult, LnurlPaymentResult, OnchainPaymentResult,
    PaymentTypes,
};
use crate::{utils, TOKIO_RUNTIME};
use anyhow::{bail, Context, Ok};
use bark::ark::bitcoin::hex::DisplayHex;
use bark::ark::bitcoin::{address, Address};
use bark::ark::lightning;
use bdk_wallet::bitcoin::{self, network, FeeRate};
use bip39::Mnemonic;
use logger::log::{self, info};
use std::path::Path;
use std::str::FromStr;

#[cxx::bridge(namespace = "bark_cxx")]
pub(crate) mod ffi {

    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct BarkVtxo {
        amount: u64,
        expiry_height: u32,
        server_pubkey: String,
        exit_delta: u16,
        anchor_point: String,
        point: String,
    }

    pub enum PaymentTypes {
        Bolt11,
        Lnurl,
        Arkoor,
        Onchain,
    }

    pub struct NewAddressResult {
        user_pubkey: String,
        ark_id: String,
        address: String,
    }

    pub struct Bolt11PaymentResult {
        bolt11_invoice: String,
        preimage: String,
        payment_type: PaymentTypes,
    }

    pub struct LnurlPaymentResult {
        lnurl: String,
        bolt11_invoice: String,
        preimage: String,
        payment_type: PaymentTypes,
    }

    pub struct ArkoorPaymentResult {
        amount_sat: u64,
        destination_pubkey: String,
        payment_type: PaymentTypes,
        vtxos: Vec<BarkVtxo>,
    }

    pub struct OnchainPaymentResult {
        txid: String,
        amount_sat: u64,
        destination_address: String,
        payment_type: PaymentTypes,
    }

    pub struct CxxArkInfo {
        network: String,
        server_pubkey: String,
        round_interval_secs: u64,
        vtxo_exit_delta: u16,
        vtxo_expiry_delta: u16,
        htlc_expiry_delta: u16,
        max_vtxo_amount_sat: u64,
    }

    pub struct ConfigOpts {
        ark: String,
        esplora: String,
        bitcoind: String,
        bitcoind_cookie: String,
        bitcoind_user: String,
        bitcoind_pass: String,
        vtxo_refresh_expiry_threshold: u32,
        fallback_fee_rate: u64,
    }

    pub struct CreateOpts {
        regtest: bool,
        signet: bool,
        bitcoin: bool,
        mnemonic: String,
        birthday_height: *const u32,
        config: ConfigOpts,
    }

    pub struct SendManyOutput {
        destination: String,
        amount_sat: u64,
    }

    pub enum RefreshModeType {
        DefaultThreshold,
        ThresholdBlocks,
        ThresholdHours,
        Counterparty,
        All,
        Specific,
    }

    pub struct OffchainBalance {
        /// Coins that are spendable in the Ark, either in-round or out-of-round.
        pub spendable: u64,
        /// Coins that are in the process of being sent over Lightning.
        pub pending_lightning_send: u64,
        /// Coins that are in the process of unilaterally exiting the Ark.
        pub pending_exit: u64,
    }

    pub struct OnChainBalance {
        /// All coinbase outputs not yet matured
        pub immature: u64,
        /// Unconfirmed UTXOs generated by a wallet tx
        pub trusted_pending: u64,
        /// Unconfirmed UTXOs received from an external wallet
        pub untrusted_pending: u64,
        /// Confirmed and immediately spendable balance
        pub confirmed: u64,
    }

    pub struct KeyPairResult {
        pub public_key: String,
        pub secret_key: String,
    }

    extern "Rust" {
        fn init_logger();
        fn create_mnemonic() -> Result<String>;
        fn is_wallet_loaded() -> bool;
        fn close_wallet() -> Result<()>;
        fn persist_config(opts: ConfigOpts) -> Result<()>;
        fn get_ark_info() -> Result<CxxArkInfo>;
        fn offchain_balance() -> Result<OffchainBalance>;
        fn derive_store_next_keypair() -> Result<KeyPairResult>;
        fn peak_keypair(index: u32) -> Result<KeyPairResult>;
        fn new_address() -> Result<NewAddressResult>;
        fn sign_message(message: &str, index: u32) -> Result<String>;
        fn sign_messsage_with_mnemonic(
            message: &str,
            mnemonic: &str,
            network: &str,
            index: u32,
        ) -> Result<String>;
        fn derive_keypair_from_mnemonic(
            mnemonic: &str,
            network: &str,
            index: u32,
        ) -> Result<KeyPairResult>;
        fn verify_message(message: &str, signature: &str, public_key: &str) -> Result<bool>;
        fn get_vtxos() -> Result<Vec<BarkVtxo>>;
        fn get_expiring_vtxos(threshold: u32) -> Result<Vec<BarkVtxo>>;
        fn bolt11_invoice(amount_msat: u64) -> Result<String>;
        fn maintenance() -> Result<()>;
        fn maintenance_refresh() -> Result<()>;
        fn sync() -> Result<()>;
        fn sync_rounds() -> Result<()>;
        fn create_wallet(datadir: &str, opts: CreateOpts) -> Result<()>;
        fn load_wallet(datadir: &str, mnemonic: &str) -> Result<()>;
        fn board_amount(amount_sat: u64) -> Result<String>;
        fn board_all() -> Result<String>;
        fn send_arkoor_payment(destination: &str, amount_sat: u64) -> Result<ArkoorPaymentResult>;
        unsafe fn send_lightning_payment(
            destination: &str,
            amount_sat: *const u64,
        ) -> Result<Bolt11PaymentResult>;
        fn send_lnaddr(addr: &str, amount_sat: u64, comment: &str) -> Result<LnurlPaymentResult>;
        fn send_round_onchain_payment(destination: &str, amount_sat: u64) -> Result<String>;
        fn offboard_specific(vtxo_ids: Vec<String>, destination_address: &str) -> Result<String>;
        fn offboard_all(destination_address: &str) -> Result<String>;
        fn finish_lightning_receive(bolt11: String) -> Result<()>;
        fn sync_exits() -> Result<()>;

        // Onchain methods
        fn onchain_balance() -> Result<OnChainBalance>;
        fn onchain_sync() -> Result<()>;
        fn onchain_list_unspent() -> Result<String>;
        fn onchain_utxos() -> Result<String>;
        fn onchain_address() -> Result<String>;
        unsafe fn onchain_send(
            destination: &str,
            amount_sat: u64,
            fee_rate: *const u64,
        ) -> Result<OnchainPaymentResult>;
        unsafe fn onchain_drain(destination: &str, fee_rate: *const u64) -> Result<String>;
        unsafe fn onchain_send_many(
            outputs: Vec<SendManyOutput>,
            fee_rate: *const u64,
        ) -> Result<String>;
    }
}

pub(crate) fn init_logger() {
    crate::init_logger()
}

pub(crate) fn create_mnemonic() -> anyhow::Result<String> {
    crate::create_mnemonic()
}

pub(crate) fn is_wallet_loaded() -> bool {
    crate::TOKIO_RUNTIME.block_on(crate::is_wallet_loaded())
}

pub(crate) fn close_wallet() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::close_wallet())
}

pub(crate) fn persist_config(opts: ffi::ConfigOpts) -> anyhow::Result<()> {
    let config_opts = utils::ConfigOpts {
        ark: Some(opts.ark),
        esplora: Some(opts.esplora),
        bitcoind: Some(opts.bitcoind),
        bitcoind_cookie: Some(opts.bitcoind_cookie),
        bitcoind_user: Some(opts.bitcoind_user),
        bitcoind_pass: Some(opts.bitcoind_pass),
        vtxo_refresh_expiry_threshold: Some(opts.vtxo_refresh_expiry_threshold),
        fallback_fee_rate: Some(opts.fallback_fee_rate),
    };

    crate::TOKIO_RUNTIME.block_on(async {
        let mut manager = crate::GLOBAL_WALLET_MANAGER.lock().await;
        manager.with_context(|ctx| {
            let mut current_config = ctx.wallet.config().clone();
            config_opts.merge_into(&mut current_config)?;
            ctx.wallet.set_config(current_config);
            ctx.wallet
                .persist_config()
                .context("Failed to persist wallet config to disk")
        })
    })
}

pub(crate) fn get_ark_info() -> anyhow::Result<ffi::CxxArkInfo> {
    let info = crate::TOKIO_RUNTIME.block_on(crate::get_ark_info())?;
    Ok(ffi::CxxArkInfo {
        network: info.network.to_string(),
        server_pubkey: info.server_pubkey.to_string(),
        round_interval_secs: info.round_interval.as_secs(),
        vtxo_exit_delta: info.vtxo_exit_delta,
        vtxo_expiry_delta: info.vtxo_expiry_delta,
        htlc_expiry_delta: info.htlc_expiry_delta,
        max_vtxo_amount_sat: info.max_vtxo_amount.map_or(0, |a| a.to_sat()),
    })
}

pub(crate) fn offchain_balance() -> anyhow::Result<ffi::OffchainBalance> {
    let balance = crate::TOKIO_RUNTIME.block_on(crate::balance())?;
    Ok(ffi::OffchainBalance {
        spendable: balance.spendable.to_sat(),
        pending_lightning_send: balance.pending_lightning_send.to_sat(),
        pending_exit: balance.pending_exit.to_sat(),
    })
}

pub(crate) fn derive_store_next_keypair() -> anyhow::Result<ffi::KeyPairResult> {
    let keypair = crate::TOKIO_RUNTIME.block_on(crate::derive_store_next_keypair())?;
    Ok(ffi::KeyPairResult {
        public_key: keypair.public_key().to_string(),
        secret_key: keypair.secret_key().display_secret().to_string(),
    })
}

pub(crate) fn peak_keypair(index: u32) -> anyhow::Result<ffi::KeyPairResult> {
    let keypair = crate::TOKIO_RUNTIME.block_on(crate::peak_keypair(index))?;
    Ok(ffi::KeyPairResult {
        public_key: keypair.public_key().to_string(),
        secret_key: keypair.secret_key().display_secret().to_string(),
    })
}

pub(crate) fn new_address() -> anyhow::Result<ffi::NewAddressResult> {
    let address = crate::TOKIO_RUNTIME.block_on(crate::new_address())?;
    Ok(ffi::NewAddressResult {
        user_pubkey: address.policy().user_pubkey().to_string(),
        ark_id: address.ark_id().to_string(),
        address: address.to_string(),
    })
}

pub(crate) fn sign_message(message: &str, index: u32) -> anyhow::Result<String> {
    let message = crate::TOKIO_RUNTIME
        .block_on(crate::sign_message(message, index))?
        .to_string();
    Ok(message)
}

pub(crate) fn sign_messsage_with_mnemonic(
    message: &str,
    mnemonic: &str,
    network: &str,
    index: u32,
) -> anyhow::Result<String> {
    let mnemonic = Mnemonic::from_str(mnemonic)
        .with_context(|| format!("Invalid mnemonic format: '{}'", mnemonic))?;

    let network = match network {
        "mainnet" => network::Network::Bitcoin,
        "regtest" => network::Network::Regtest,
        "signet" => network::Network::Signet,
        _ => bail!("Invalid network format: '{}'", network),
    };

    let message = crate::TOKIO_RUNTIME
        .block_on(crate::sign_messsage_with_mnemonic(
            message, mnemonic, network, index,
        ))?
        .to_string();
    Ok(message)
}

pub(crate) fn derive_keypair_from_mnemonic(
    mnemonic: &str,
    network: &str,
    index: u32,
) -> anyhow::Result<ffi::KeyPairResult> {
    let mnemonic = bip39::Mnemonic::from_str(mnemonic)
        .with_context(|| format!("Invalid mnemonic format: '{}'", mnemonic))?;
    let network = match network {
        "mainnet" => network::Network::Bitcoin,
        "regtest" => network::Network::Regtest,
        "signet" => network::Network::Signet,
        _ => bail!("Invalid network format: '{}'", network),
    };

    let keypair = crate::TOKIO_RUNTIME.block_on(crate::derive_keypair_from_mnemonic(
        mnemonic, network, index,
    ))?;

    Ok(ffi::KeyPairResult {
        public_key: keypair.public_key().to_string(),
        secret_key: keypair.secret_key().display_secret().to_string(),
    })
}

pub(crate) fn verify_message(
    message: &str,
    signature: &str,
    public_key: &str,
) -> anyhow::Result<bool> {
    let signature = bark::ark::bitcoin::secp256k1::ecdsa::Signature::from_str(signature)
        .with_context(|| format!("Invalid signature format: '{}'", signature))?;
    let public_key = bark::ark::bitcoin::secp256k1::PublicKey::from_str(public_key)
        .with_context(|| format!("Invalid public key format: '{}'", public_key))?;

    crate::TOKIO_RUNTIME.block_on(crate::verify_message(message, signature, &public_key))
}

pub(crate) fn get_vtxos() -> anyhow::Result<Vec<BarkVtxo>> {
    let vtxos = crate::TOKIO_RUNTIME.block_on(crate::get_vtxos())?;

    Ok(vtxos
        .into_iter()
        .map(|vtxo| BarkVtxo {
            amount: vtxo.amount().to_sat(),
            expiry_height: vtxo.expiry_height(),
            server_pubkey: vtxo.server_pubkey().to_string(),
            exit_delta: vtxo.exit_delta(),
            anchor_point: format!(
                "{}:{}",
                vtxo.chain_anchor().txid.to_string(),
                vtxo.chain_anchor().vout.to_string()
            ),
            point: format!(
                "{}:{}",
                vtxo.point().txid.to_string(),
                vtxo.point().vout.to_string()
            ),
        })
        .collect())
}

pub(crate) fn get_expiring_vtxos(threshold: u32) -> anyhow::Result<Vec<BarkVtxo>> {
    let expiring_vtxos = crate::TOKIO_RUNTIME.block_on(crate::get_expiring_vtxos(threshold))?;

    Ok(expiring_vtxos
        .into_iter()
        .map(|vtxo| BarkVtxo {
            amount: vtxo.amount().to_sat(),
            expiry_height: vtxo.expiry_height(),
            server_pubkey: vtxo.server_pubkey().to_string(),
            exit_delta: vtxo.exit_delta(),
            anchor_point: format!(
                "{}:{}",
                vtxo.chain_anchor().txid.to_string(),
                vtxo.chain_anchor().vout.to_string()
            ),
            point: format!(
                "{}:{}",
                vtxo.point().txid.to_string(),
                vtxo.point().vout.to_string()
            ),
        })
        .collect())
}

pub(crate) fn bolt11_invoice(amount_msat: u64) -> anyhow::Result<String> {
    crate::TOKIO_RUNTIME.block_on(crate::bolt11_invoice(amount_msat))
}

pub(crate) fn maintenance() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::maintenance())
}

pub(crate) fn maintenance_refresh() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::maintenance_refresh())
}

pub(crate) fn sync() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::sync())
}

pub(crate) fn sync_rounds() -> anyhow::Result<()> {
    crate::TOKIO_RUNTIME.block_on(crate::sync_rounds())
}

pub(crate) fn create_wallet(datadir: &str, opts: ffi::CreateOpts) -> anyhow::Result<()> {
    let config_opts = utils::ConfigOpts {
        ark: Some(opts.config.ark),
        esplora: Some(opts.config.esplora),
        bitcoind: Some(opts.config.bitcoind),
        bitcoind_cookie: Some(opts.config.bitcoind_cookie),
        bitcoind_user: Some(opts.config.bitcoind_user),
        bitcoind_pass: Some(opts.config.bitcoind_pass),
        vtxo_refresh_expiry_threshold: Some(opts.config.vtxo_refresh_expiry_threshold),
        fallback_fee_rate: Some(opts.config.fallback_fee_rate),
    };

    log::info!(
        "Creating wallet with datadir: {}, regtest: {}, signet: {}, bitcoin: {}, birthday_height: {:?}",
        datadir,
        opts.regtest,
        opts.signet,
        opts.bitcoin,
        unsafe { opts.birthday_height.as_ref().map(|r| *r) }
    );

    let create_opts = utils::CreateOpts {
        regtest: opts.regtest,
        signet: opts.signet,
        bitcoin: opts.bitcoin,
        mnemonic: bip39::Mnemonic::from_str(&opts.mnemonic)?,
        birthday_height: unsafe { opts.birthday_height.as_ref().map(|r| *r) },
        config: config_opts,
    };

    log::info!("Creating wallet with options: {:?}", create_opts);

    crate::TOKIO_RUNTIME.block_on(crate::create_wallet(Path::new(datadir), create_opts))
}

pub(crate) fn load_wallet(datadir: &str, mnemonic: &str) -> anyhow::Result<()> {
    let mnemonic = bip39::Mnemonic::from_str(mnemonic)
        .with_context(|| format!("Invalid mnemonic format: '{}'", mnemonic))?;

    log::info!("Loading wallet with datadir: {}", datadir);

    crate::TOKIO_RUNTIME.block_on(crate::load_wallet(Path::new(datadir), mnemonic))
}

pub(crate) fn board_amount(amount_sat: u64) -> anyhow::Result<String> {
    let amount = bark::ark::bitcoin::Amount::from_sat(amount_sat);
    crate::TOKIO_RUNTIME.block_on(crate::board_amount(amount))
}

pub(crate) fn board_all() -> anyhow::Result<String> {
    crate::TOKIO_RUNTIME.block_on(crate::board_all())
}

pub(crate) fn send_arkoor_payment(
    destination: &str,
    amount_sat: u64,
) -> anyhow::Result<ArkoorPaymentResult> {
    let amount = bark::ark::bitcoin::Amount::from_sat(amount_sat);
    let dest = bark::ark::Address::from_str(destination)
        .with_context(|| format!("Invalid destination address format: '{}'", destination))?;
    let oor_result = crate::TOKIO_RUNTIME.block_on(crate::send_arkoor_payment(dest, amount))?;

    Ok(ArkoorPaymentResult {
        vtxos: oor_result
            .iter()
            .map(|vtxo| BarkVtxo {
                amount: vtxo.amount().to_sat(),
                expiry_height: vtxo.expiry_height(),
                server_pubkey: vtxo.server_pubkey().to_string(),
                exit_delta: vtxo.exit_delta(),
                anchor_point: format!(
                    "{}:{}",
                    vtxo.chain_anchor().txid.to_string(),
                    vtxo.chain_anchor().vout.to_string()
                ),
                point: format!(
                    "{}:{}",
                    vtxo.point().txid.to_string(),
                    vtxo.point().vout.to_string()
                ),
            })
            .collect(),
        destination_pubkey: destination.to_string(),
        amount_sat,
        payment_type: PaymentTypes::Arkoor,
    })
}

pub(crate) fn send_lightning_payment(
    destination: &str,
    amount_sat: *const u64,
) -> anyhow::Result<Bolt11PaymentResult> {
    let amount_opt = match unsafe { amount_sat.as_ref().map(|r| *r) } {
        Some(amount) => Some(bark::ark::bitcoin::Amount::from_sat(amount)),
        None => None,
    };

    let invoice = lightning::Invoice::from_str(destination)?;

    let preimage = crate::TOKIO_RUNTIME
        .block_on(crate::send_lightning_payment(invoice, amount_opt))?
        .to_lower_hex_string();

    Ok(Bolt11PaymentResult {
        preimage,
        bolt11_invoice: destination.to_string(),
        payment_type: PaymentTypes::Bolt11,
    })
}

pub(crate) fn send_lnaddr(
    addr: &str,
    amount_sat: u64,
    comment: &str,
) -> anyhow::Result<LnurlPaymentResult> {
    let amount = bark::ark::bitcoin::Amount::from_sat(amount_sat);
    let comment_opt = if comment.is_empty() {
        None
    } else {
        Some(comment)
    };
    let send_lnaddr_result =
        crate::TOKIO_RUNTIME.block_on(crate::send_lnaddr(addr, amount, comment_opt))?;

    Ok(LnurlPaymentResult {
        preimage: send_lnaddr_result.1.to_lower_hex_string(),
        bolt11_invoice: send_lnaddr_result.0.to_string(),
        lnurl: addr.to_string(),
        payment_type: PaymentTypes::Lnurl,
    })
}

pub(crate) fn send_round_onchain_payment(
    destination: &str,
    amount_sat: u64,
) -> anyhow::Result<String> {
    let amount = bark::ark::bitcoin::Amount::from_sat(amount_sat);
    let address_unchecked = bitcoin::Address::from_str(destination)
        .with_context(|| format!("Invalid destination address format: '{}'", destination))?;

    let ark_info = crate::TOKIO_RUNTIME.block_on(crate::get_ark_info())?;

    // Now require the network to match the wallet's network
    let destination_address = address_unchecked
        .require_network(ark_info.network)
        .with_context(|| {
            format!(
                "address '{}' is not valid for configured network {}",
                destination, ark_info.network
            )
        })?;

    let result = crate::TOKIO_RUNTIME.block_on(crate::send_round_onchain_payment(
        destination_address,
        amount,
    ))?;

    Ok(result.round.to_string())
}

pub(crate) fn offboard_specific(
    vtxo_ids: Vec<String>,
    destination_address: &str,
) -> anyhow::Result<String> {
    let ids = vtxo_ids
        .into_iter()
        .map(|s| bark::ark::VtxoId::from_str(&s))
        .collect::<Result<Vec<_>, _>>()?;

    let ark_info = crate::TOKIO_RUNTIME.block_on(crate::get_ark_info())?;

    let destination_address_opt = Address::<address::NetworkUnchecked>::from_str(
        &destination_address,
    )
    .with_context(|| {
        format!(
            "Invalid destination address format: '{}'",
            destination_address
        )
    })?;
    let addr = destination_address_opt
        .require_network(ark_info.network)
        .with_context(|| {
            format!(
                "Address '{}' is not valid for configured network {:?}",
                destination_address, ark_info.network
            )
        })?;

    if ids.is_empty() {
        bail!("At least one VTXO ID must be provided for specific offboarding");
    }

    info!(
        "Attempting to offboard {} specific VTXOs to {:?}",
        ids.len(),
        addr
    );

    let offboard_specific_result =
        crate::TOKIO_RUNTIME.block_on(crate::offboard_specific(ids, addr))?;

    Ok(offboard_specific_result.round.to_string())
}

pub(crate) fn offboard_all(destination_address: &str) -> anyhow::Result<String> {
    let ark_info = crate::TOKIO_RUNTIME.block_on(crate::get_ark_info())?;

    let destination_address_opt = Address::<address::NetworkUnchecked>::from_str(
        &destination_address,
    )
    .with_context(|| {
        format!(
            "Invalid destination address format: '{}'",
            destination_address
        )
    })?;
    let addr = destination_address_opt
        .require_network(ark_info.network)
        .with_context(|| {
            format!(
                "Address '{}' is not valid for configured network {:?}",
                destination_address, ark_info.network
            )
        })?;

    info!("Attempting to offboard all VTXOs to {:?}", addr);

    let offboard_all_result = crate::TOKIO_RUNTIME.block_on(crate::offboard_all(addr))?;

    Ok(offboard_all_result.round.to_string())
}

pub(crate) fn finish_lightning_receive(bolt11: String) -> anyhow::Result<()> {
    let invoice = bolt11.parse()?;
    TOKIO_RUNTIME.block_on(crate::finish_lightning_receive(invoice))
}

pub(crate) fn sync_exits() -> anyhow::Result<()> {
    TOKIO_RUNTIME.block_on(crate::sync_exits())
}

// Onchain methods

pub(crate) fn onchain_list_unspent() -> anyhow::Result<String> {
    let unspent = TOKIO_RUNTIME.block_on(crate::onchain::list_unspent())?;
    serde_json::to_string(&unspent).map_err(Into::into)
}

pub(crate) fn onchain_sync() -> anyhow::Result<()> {
    let _ = crate::TOKIO_RUNTIME.block_on(crate::onchain::sync())?;
    Ok(())
}

pub(crate) fn onchain_address() -> anyhow::Result<String> {
    let address = crate::TOKIO_RUNTIME.block_on(crate::onchain::address())?;
    Ok(address.to_string())
}

pub(crate) fn onchain_balance() -> anyhow::Result<ffi::OnChainBalance> {
    let balance = crate::TOKIO_RUNTIME.block_on(crate::onchain::onchain_balance())?;
    Ok(ffi::OnChainBalance {
        immature: balance.immature.to_sat(),
        trusted_pending: balance.trusted_pending.to_sat(),
        untrusted_pending: balance.untrusted_pending.to_sat(),
        confirmed: balance.confirmed.to_sat(),
    })
}

pub(crate) fn onchain_utxos() -> anyhow::Result<String> {
    let utxos = crate::TOKIO_RUNTIME.block_on(async { crate::onchain::utxos().await })?;

    let res = utxos
        .iter()
        .map(|utxo| match utxo {
            bark::onchain::Utxo::Local(local) => serde_json::json!({
                "outpoint": format!("{}:{}", local.outpoint.txid, local.outpoint.vout),
                "amount": local.amount.to_sat(),
                "confirmation_height": local.confirmation_height.map_or(0, |_h| 0),
            }),
            bark::onchain::Utxo::Exit(exit) => serde_json::json!({
                "vtxo": BarkVtxo {
                    amount: exit.vtxo.amount().to_sat(),
                    anchor_point: format!("{}:{}", exit.vtxo.chain_anchor().txid, exit.vtxo.chain_anchor().vout),
                    exit_delta: exit.vtxo.exit_delta(),
                    server_pubkey: exit.vtxo.server_pubkey().to_string(),
                    expiry_height: exit.vtxo.expiry_height(),
                    point: format!("{}:{}", exit.vtxo.point().txid.to_string(), exit.vtxo.point().vout.to_string()),
                },
                "height": exit.height
            }),
        })
        .collect::<Vec<_>>();

    serde_json::to_string(&res).map_err(Into::into)
}

pub(crate) fn onchain_send(
    destination: &str,
    amount_sat: u64,
    fee_rate: *const u64,
) -> anyhow::Result<OnchainPaymentResult> {
    let amount = bark::ark::bitcoin::Amount::from_sat(amount_sat);

    let ark_info = crate::TOKIO_RUNTIME.block_on(crate::get_ark_info())?;

    // Validate optional address string
    let address_unchecked = Address::<address::NetworkUnchecked>::from_str(destination)
        .with_context(|| format!("invalid destination address format: '{}'", destination))?;

    // Now require the network to match the wallet's network
    let destination_address = address_unchecked
        .require_network(ark_info.network)
        .with_context(|| {
            format!(
                "address '{}' is not valid for configured network {}",
                destination, ark_info.network
            )
        })?;

    let txid = crate::TOKIO_RUNTIME.block_on(async {
        let fee_rate = if fee_rate.is_null() {
            let mut manager = crate::GLOBAL_WALLET_MANAGER.lock().await;
            manager
                .with_context_async(|ctx| async { Ok(ctx.wallet.chain.fee_rates().await.regular) })
                .await?
        } else {
            FeeRate::from_sat_per_vb(unsafe { *fee_rate }).context("Invalid fee rate")?
        };

        crate::onchain::send(destination_address.clone(), amount, fee_rate).await
    })?;

    Ok(OnchainPaymentResult {
        txid: txid.to_string(),
        amount_sat,
        destination_address: destination_address.to_string(),
        payment_type: PaymentTypes::Onchain,
    })
}

pub(crate) fn onchain_drain(destination: &str, fee_rate: *const u64) -> anyhow::Result<String> {
    let txid = crate::TOKIO_RUNTIME.block_on(async {
        let mut manager = crate::GLOBAL_WALLET_MANAGER.lock().await;
        let (address, fee_rate) = manager
            .with_context_async(|ctx| async {
                let net = ctx.wallet.properties().unwrap().network;
                let address = Address::from_str(destination)?
                    .require_network(net)
                    .context("Address on wrong network")?;
                let fee_rate = if fee_rate.is_null() {
                    ctx.wallet.chain.fee_rates().await.regular
                } else {
                    FeeRate::from_sat_per_vb(unsafe { *fee_rate }).context("Invalid fee rate")?
                };
                Ok((address, fee_rate))
            })
            .await?;

        crate::onchain::drain(address, fee_rate).await
    })?;
    Ok(txid.to_string())
}

pub(crate) fn onchain_send_many(
    outputs: Vec<ffi::SendManyOutput>,
    fee_rate: *const u64,
) -> anyhow::Result<String> {
    let txid = crate::TOKIO_RUNTIME.block_on(async {
        let mut manager = crate::GLOBAL_WALLET_MANAGER.lock().await;
        let (rust_outputs, fee_rate) = manager
            .with_context_async(|ctx| async {
                let mut rust_outputs = Vec::new();
                let net = ctx.wallet.properties().unwrap().network;
                for output in outputs {
                    let address = Address::from_str(&output.destination)
                        .context("Invalid address format")?
                        .require_network(net)
                        .context("Address on wrong network")?;
                    let amount = bark::ark::bitcoin::Amount::from_sat(output.amount_sat);
                    rust_outputs.push((address, amount));
                }

                let fee_rate = if fee_rate.is_null() {
                    ctx.wallet.chain.fee_rates().await.regular
                } else {
                    FeeRate::from_sat_per_vb(unsafe { *fee_rate }).context("Invalid fee rate")?
                };
                Ok((rust_outputs, fee_rate))
            })
            .await?;

        crate::onchain::send_many(rust_outputs, fee_rate).await
    })?;
    Ok(txid.to_string())
}
