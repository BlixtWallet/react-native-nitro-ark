///
/// BarkConfigOpts.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/JSIConverter.hpp>)
#include <NitroModules/JSIConverter.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif
#if __has_include(<NitroModules/NitroDefines.hpp>)
#include <NitroModules/NitroDefines.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif



#include <optional>
#include <string>

namespace margelo::nitro::nitroark {

  /**
   * A struct which can be represented as a JavaScript object (BarkConfigOpts).
   */
  struct BarkConfigOpts {
  public:
    std::optional<std::string> asp     SWIFT_PRIVATE;
    std::optional<std::string> esplora     SWIFT_PRIVATE;
    std::optional<std::string> bitcoind     SWIFT_PRIVATE;
    std::optional<std::string> bitcoind_cookie     SWIFT_PRIVATE;
    std::optional<std::string> bitcoind_user     SWIFT_PRIVATE;
    std::optional<std::string> bitcoind_pass     SWIFT_PRIVATE;
    std::optional<double> vtxo_refresh_expiry_threshold     SWIFT_PRIVATE;
    std::optional<double> fallback_fee_rate     SWIFT_PRIVATE;

  public:
    BarkConfigOpts() = default;
    explicit BarkConfigOpts(std::optional<std::string> asp, std::optional<std::string> esplora, std::optional<std::string> bitcoind, std::optional<std::string> bitcoind_cookie, std::optional<std::string> bitcoind_user, std::optional<std::string> bitcoind_pass, std::optional<double> vtxo_refresh_expiry_threshold, std::optional<double> fallback_fee_rate): asp(asp), esplora(esplora), bitcoind(bitcoind), bitcoind_cookie(bitcoind_cookie), bitcoind_user(bitcoind_user), bitcoind_pass(bitcoind_pass), vtxo_refresh_expiry_threshold(vtxo_refresh_expiry_threshold), fallback_fee_rate(fallback_fee_rate) {}
  };

} // namespace margelo::nitro::nitroark

namespace margelo::nitro {

  using namespace margelo::nitro::nitroark;

  // C++ BarkConfigOpts <> JS BarkConfigOpts (object)
  template <>
  struct JSIConverter<BarkConfigOpts> final {
    static inline BarkConfigOpts fromJSI(jsi::Runtime& runtime, const jsi::Value& arg) {
      jsi::Object obj = arg.asObject(runtime);
      return BarkConfigOpts(
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "asp")),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "esplora")),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "bitcoind")),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "bitcoind_cookie")),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "bitcoind_user")),
        JSIConverter<std::optional<std::string>>::fromJSI(runtime, obj.getProperty(runtime, "bitcoind_pass")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "vtxo_refresh_expiry_threshold")),
        JSIConverter<std::optional<double>>::fromJSI(runtime, obj.getProperty(runtime, "fallback_fee_rate"))
      );
    }
    static inline jsi::Value toJSI(jsi::Runtime& runtime, const BarkConfigOpts& arg) {
      jsi::Object obj(runtime);
      obj.setProperty(runtime, "asp", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.asp));
      obj.setProperty(runtime, "esplora", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.esplora));
      obj.setProperty(runtime, "bitcoind", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.bitcoind));
      obj.setProperty(runtime, "bitcoind_cookie", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.bitcoind_cookie));
      obj.setProperty(runtime, "bitcoind_user", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.bitcoind_user));
      obj.setProperty(runtime, "bitcoind_pass", JSIConverter<std::optional<std::string>>::toJSI(runtime, arg.bitcoind_pass));
      obj.setProperty(runtime, "vtxo_refresh_expiry_threshold", JSIConverter<std::optional<double>>::toJSI(runtime, arg.vtxo_refresh_expiry_threshold));
      obj.setProperty(runtime, "fallback_fee_rate", JSIConverter<std::optional<double>>::toJSI(runtime, arg.fallback_fee_rate));
      return obj;
    }
    static inline bool canConvert(jsi::Runtime& runtime, const jsi::Value& value) {
      if (!value.isObject()) {
        return false;
      }
      jsi::Object obj = value.getObject(runtime);
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "asp"))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "esplora"))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "bitcoind"))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "bitcoind_cookie"))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "bitcoind_user"))) return false;
      if (!JSIConverter<std::optional<std::string>>::canConvert(runtime, obj.getProperty(runtime, "bitcoind_pass"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "vtxo_refresh_expiry_threshold"))) return false;
      if (!JSIConverter<std::optional<double>>::canConvert(runtime, obj.getProperty(runtime, "fallback_fee_rate"))) return false;
      return true;
    }
  };

} // namespace margelo::nitro
